## API Report File for "@azure/msal-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

// @public
export const AADAuthorityConstants: {
    readonly COMMON: "common";
    readonly ORGANIZATIONS: "organizations";
    readonly CONSUMERS: "consumers";
};

// @public (undocumented)
export type AADAuthorityConstants = (typeof AADAuthorityConstants)[keyof typeof AADAuthorityConstants];

declare namespace AADServerParamKeys {
    export {
        CLIENT_ID,
        REDIRECT_URI,
        RESPONSE_TYPE,
        RESPONSE_MODE,
        GRANT_TYPE,
        CLAIMS,
        SCOPE,
        ERROR,
        ERROR_DESCRIPTION,
        ACCESS_TOKEN,
        ID_TOKEN,
        REFRESH_TOKEN,
        EXPIRES_IN,
        REFRESH_TOKEN_EXPIRES_IN,
        STATE,
        NONCE,
        PROMPT,
        SESSION_STATE,
        CLIENT_INFO,
        CODE,
        CODE_CHALLENGE,
        CODE_CHALLENGE_METHOD,
        CODE_VERIFIER,
        CLIENT_REQUEST_ID,
        X_CLIENT_SKU,
        X_CLIENT_VER,
        X_CLIENT_OS,
        X_CLIENT_CPU,
        X_CLIENT_CURR_TELEM,
        X_CLIENT_LAST_TELEM,
        X_MS_LIB_CAPABILITY,
        X_APP_NAME,
        X_APP_VER,
        POST_LOGOUT_URI,
        ID_TOKEN_HINT,
        DEVICE_CODE,
        CLIENT_SECRET,
        CLIENT_ASSERTION,
        CLIENT_ASSERTION_TYPE,
        TOKEN_TYPE,
        REQ_CNF,
        OBO_ASSERTION,
        REQUESTED_TOKEN_USE,
        ON_BEHALF_OF,
        FOCI,
        CCS_HEADER,
        RETURN_SPA_CODE,
        NATIVE_BROKER,
        LOGOUT_HINT,
        SID,
        LOGIN_HINT,
        DOMAIN_HINT
    }
}
export { AADServerParamKeys }

// @public (undocumented)
const ACCESS_TOKEN = "access_token";

// Warning: (ae-internal-missing-underscore) The name "AccessTokenCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AccessTokenCache = Record<string, AccessTokenEntity>;

// @public
export type AccessTokenEntity = CredentialEntity & {
    realm: string;
    target: string;
    cachedAt: string;
    expiresOn: string;
    extendedExpiresOn?: string;
    refreshOn?: string;
    tokenType?: AuthenticationScheme;
    requestedClaims?: string;
    requestedClaimsHash?: string;
};

// Warning: (ae-internal-missing-underscore) The name "AccountCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AccountCache = Record<string, AccountEntity>;

// Warning: (ae-internal-missing-underscore) The name "AccountEntity" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class AccountEntity {
    static accountInfoIsEqual(accountA: AccountInfo | null, accountB: AccountInfo | null, compareClaims?: boolean): boolean;
    // (undocumented)
    authorityType: string;
    // (undocumented)
    clientInfo?: string;
    // (undocumented)
    cloudGraphHostName?: string;
    static createAccount(accountDetails: {
        homeAccountId: string;
        idTokenClaims: TokenClaims;
        clientInfo?: string;
        cloudGraphHostName?: string;
        msGraphHost?: string;
        environment?: string;
        nativeAccountId?: string;
        tenantProfiles?: Array<TenantProfile>;
    }, authority: Authority, base64Decode?: (input: string) => string): AccountEntity;
    static createFromAccountInfo(accountInfo: AccountInfo, cloudGraphHostName?: string, msGraphHost?: string): AccountEntity;
    // (undocumented)
    environment: string;
    static generateAccountCacheKey(accountInterface: AccountInfo): string;
    generateAccountId(): string;
    generateAccountKey(): string;
    static generateHomeAccountId(serverClientInfo: string, authType: AuthorityType, logger: Logger, cryptoObj: ICrypto, idTokenClaims?: TokenClaims): string;
    getAccountInfo(): AccountInfo;
    // (undocumented)
    homeAccountId: string;
    static isAccountEntity(entity: object): boolean;
    isSingleTenant(): boolean;
    // (undocumented)
    lastModificationApp?: string;
    // (undocumented)
    lastModificationTime?: string;
    // (undocumented)
    localAccountId: string;
    // (undocumented)
    msGraphHost?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    nativeAccountId?: string;
    // (undocumented)
    realm: string;
    // (undocumented)
    tenantProfiles?: Array<TenantProfile>;
    // (undocumented)
    username: string;
}

// @public
export type AccountFilter = Omit<Partial<AccountInfo>, "idToken" | "idTokenClaims"> & {
    realm?: string;
    loginHint?: string;
    sid?: string;
    isHomeTenant?: boolean;
};

// @public
export type AccountInfo = {
    homeAccountId: string;
    environment: string;
    tenantId: string;
    username: string;
    localAccountId: string;
    name?: string;
    idToken?: string;
    idTokenClaims?: TokenClaims & {
        [key: string]: string | number | string[] | object | undefined | unknown;
    };
    nativeAccountId?: string;
    authorityType?: string;
    tenantProfiles?: Map<string, TenantProfile>;
};

// @public (undocumented)
export type ActiveAccountFilters = {
    homeAccountId: string;
    localAccountId: string;
    tenantId?: string;
};

// @public
export type ApplicationTelemetry = {
    appName: string;
    appVersion: string;
};

// Warning: (ae-internal-missing-underscore) The name "AppMetadataCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AppMetadataCache = Record<string, AppMetadataEntity>;

// @public
export type AppMetadataEntity = {
    clientId: string;
    environment: string;
    familyId?: string;
};

// @public
export type AppTokenProviderParameters = {
    readonly correlationId?: string;
    readonly tenantId: string;
    readonly scopes: Array<string>;
    readonly claims?: string;
};

// @public
export type AppTokenProviderResult = {
    accessToken: string;
    expiresInSeconds: number;
    refreshInSeconds?: number;
};

// @public
export class AuthenticationHeaderParser {
    constructor(headers: Record<string, string>);
    getShrNonce(): string;
}

// @public
export type AuthenticationResult = {
    authority: string;
    uniqueId: string;
    tenantId: string;
    scopes: Array<string>;
    account: AccountInfo | null;
    idToken: string;
    idTokenClaims: object;
    accessToken: string;
    fromCache: boolean;
    expiresOn: Date | null;
    extExpiresOn?: Date;
    refreshOn?: Date;
    tokenType: string;
    correlationId: string;
    requestId?: string;
    state?: string;
    familyId?: string;
    cloudGraphHostName?: string;
    msGraphHost?: string;
    code?: string;
    fromNativeBroker?: boolean;
};

// @public
export const AuthenticationScheme: {
    readonly BEARER: "Bearer";
    readonly POP: "pop";
    readonly SSH: "ssh-cert";
};

// @public (undocumented)
export type AuthenticationScheme = (typeof AuthenticationScheme)[keyof typeof AuthenticationScheme];

// @public
export class AuthError extends Error {
    constructor(errorCode?: string, errorMessage?: string, suberror?: string);
    correlationId: string;
    errorCode: string;
    errorMessage: string;
    // (undocumented)
    setCorrelationId(correlationId: string): void;
    subError: string;
}

declare namespace AuthErrorCodes {
    export {
        unexpectedError,
        postRequestFailed
    }
}
export { AuthErrorCodes }

// @public @deprecated
export const AuthErrorMessage: {
    unexpectedError: {
        code: string;
        desc: string;
    };
    postRequestFailed: {
        code: string;
        desc: string;
    };
};

// Warning: (ae-internal-missing-underscore) The name "AuthOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type AuthOptions = {
    clientId: string;
    authority: Authority;
    clientCapabilities?: Array<string>;
    azureCloudOptions?: AzureCloudOptions;
    skipAuthorityMetadataCache?: boolean;
};

// Warning: (ae-internal-missing-underscore) The name "Authority" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class Authority {
    constructor(authority: string, networkInterface: INetworkModule, cacheManager: ICacheManager, authorityOptions: AuthorityOptions, logger: Logger, correlationId: string, performanceClient?: IPerformanceClient, managedIdentity?: boolean);
    // (undocumented)
    get authorityType(): AuthorityType;
    get authorizationEndpoint(): string;
    static buildRegionalAuthorityString(host: string, region: string, queryString?: string): string;
    // Warning: (ae-forgotten-export) The symbol "ICacheManager" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected cacheManager: ICacheManager;
    get canonicalAuthority(): string;
    set canonicalAuthority(url: string);
    get canonicalAuthorityUrlComponents(): IUri;
    // (undocumented)
    protected correlationId: string;
    // Warning: (ae-forgotten-export) The symbol "CloudDiscoveryMetadata" needs to be exported by the entry point index.d.ts
    static createCloudDiscoveryMetadataFromHost(host: string): CloudDiscoveryMetadata;
    protected get defaultOpenIdConfigurationEndpoint(): string;
    // (undocumented)
    get deviceCodeEndpoint(): string;
    discoveryComplete(): boolean;
    get endSessionEndpoint(): string;
    static generateAuthority(authorityString: string, azureCloudOptions?: AzureCloudOptions): string;
    getPreferredCache(): string;
    get hostnameAndPort(): string;
    isAlias(host: string): boolean;
    isAliasOfKnownMicrosoftAuthority(host: string): boolean;
    static isPublicCloudAuthority(host: string): boolean;
    get jwksUri(): string;
    // (undocumented)
    protected networkInterface: INetworkModule;
    get options(): AuthorityOptions;
    // (undocumented)
    protected performanceClient: IPerformanceClient | undefined;
    get protocolMode(): ProtocolMode;
    // Warning: (ae-forgotten-export) The symbol "RegionDiscoveryMetadata" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    regionDiscoveryMetadata: RegionDiscoveryMetadata;
    // Warning: (ae-forgotten-export) The symbol "OpenIdConfigResponse" needs to be exported by the entry point index.d.ts
    static replaceWithRegionalInformation(metadata: OpenIdConfigResponse, azureRegion: string): OpenIdConfigResponse;
    resolveEndpointsAsync(): Promise<void>;
    get selfSignedJwtAudience(): string;
    get tenant(): string;
    get tokenEndpoint(): string;
    static transformCIAMAuthority(authority: string): string;
}

declare namespace AuthorityFactory {
    export {
        createDiscoveredInstance
    }
}
export { AuthorityFactory }

// Warning: (ae-internal-missing-underscore) The name "AuthorityMetadataEntity" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AuthorityMetadataEntity = {
    aliases: Array<string>;
    preferred_cache: string;
    preferred_network: string;
    canonical_authority: string;
    authorization_endpoint: string;
    token_endpoint: string;
    end_session_endpoint?: string;
    issuer: string;
    aliasesFromNetwork: boolean;
    endpointsFromNetwork: boolean;
    expiresAt: number;
    jwks_uri: string;
};

// @public (undocumented)
const authorityMismatch = "authority_mismatch";

// @public (undocumented)
export type AuthorityOptions = {
    protocolMode: ProtocolMode;
    OIDCOptions?: OIDCOptions | null;
    knownAuthorities: Array<string>;
    cloudDiscoveryMetadata: string;
    authorityMetadata: string;
    skipAuthorityMetadataCache?: boolean;
    azureRegionConfiguration?: AzureRegionConfiguration;
    authority?: string;
};

// @public
export const AuthorityType: {
    readonly Default: 0;
    readonly Adfs: 1;
    readonly Dsts: 2;
    readonly Ciam: 3;
};

// @public (undocumented)
export type AuthorityType = (typeof AuthorityType)[keyof typeof AuthorityType];

// @public (undocumented)
const authorityUriInsecure = "authority_uri_insecure";

// Warning: (ae-internal-missing-underscore) The name "AuthorizationCodeClient" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class AuthorizationCodeClient extends BaseClient {
    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient);
    acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult>;
    getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string>;
    getLogoutUri(logoutRequest: CommonEndSessionRequest): string;
    handleFragmentResponse(serverParams: ServerAuthorizationCodeResponse, cachedState: string): AuthorizationCodePayload;
    // (undocumented)
    protected includeRedirectUri: boolean;
}

// @public (undocumented)
const authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";

// @public
export type AuthorizationCodePayload = {
    code: string;
    cloud_instance_name?: string;
    cloud_instance_host_name?: string;
    cloud_graph_host_name?: string;
    msgraph_host?: string;
    state?: string;
    nonce?: string;
    client_info?: string;
};

// @public (undocumented)
const authTimeNotFound = "auth_time_not_found";

declare namespace AuthToken {
    export {
        extractTokenClaims,
        getJWSPayload,
        checkMaxAge
    }
}
export { AuthToken }

// @public (undocumented)
export const AzureCloudInstance: {
    readonly None: "none";
    readonly AzurePublic: "https://login.microsoftonline.com";
    readonly AzurePpe: "https://login.windows-ppe.net";
    readonly AzureChina: "https://login.chinacloudapi.cn";
    readonly AzureGermany: "https://login.microsoftonline.de";
    readonly AzureUsGovernment: "https://login.microsoftonline.us";
};

// @public (undocumented)
export type AzureCloudInstance = (typeof AzureCloudInstance)[keyof typeof AzureCloudInstance];

// @public
export type AzureCloudOptions = {
    azureCloudInstance: AzureCloudInstance;
    tenant?: string;
};

// @public (undocumented)
export type AzureRegion = string;

// @public (undocumented)
export type AzureRegionConfiguration = {
    azureRegion?: AzureRegion;
    environmentRegion: string | undefined;
};

// @public (undocumented)
const badToken = "bad_token";

// @public
export type BaseAuthRequest = {
    authority: string;
    correlationId: string;
    scopes: Array<string>;
    authenticationScheme?: AuthenticationScheme;
    claims?: string;
    shrClaims?: string;
    shrNonce?: string;
    shrOptions?: ShrOptions;
    resourceRequestMethod?: string;
    resourceRequestUri?: string;
    sshJwk?: string;
    sshKid?: string;
    azureCloudOptions?: AzureCloudOptions;
    requestedClaimsHash?: string;
    maxAge?: number;
    tokenQueryParameters?: StringDict;
    storeInCache?: StoreInCache;
    scenarioId?: string;
};

// Warning: (ae-internal-missing-underscore) The name "BaseClient" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export abstract class BaseClient {
    protected constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient);
    // (undocumented)
    authority: Authority;
    // (undocumented)
    protected cacheManager: CacheManager;
    // Warning: (ae-forgotten-export) The symbol "CommonClientConfiguration" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected config: CommonClientConfiguration;
    createTokenQueryParameters(request: BaseAuthRequest): string;
    protected createTokenRequestHeaders(ccsCred?: CcsCredential): Record<string, string>;
    // (undocumented)
    protected cryptoUtils: ICrypto;
    protected executePostToTokenEndpoint(tokenEndpoint: string, queryString: string, headers: Record<string, string>, thumbprint: RequestThumbprint, correlationId: string, queuedEvent?: string): Promise<NetworkResponse<ServerAuthorizationTokenResponse>>;
    // (undocumented)
    logger: Logger;
    // (undocumented)
    protected networkClient: INetworkModule;
    // (undocumented)
    protected networkManager: NetworkManager;
    // (undocumented)
    protected performanceClient?: IPerformanceClient;
    // (undocumented)
    protected serverTelemetryManager: ServerTelemetryManager | null;
    updateAuthority(cloudInstanceHostname: string, correlationId: string): Promise<void>;
}

// @public (undocumented)
const bindingKeyNotRemoved = "binding_key_not_removed";

// Warning: (ae-incompatible-release-tags) The symbol "buildAccountToCache" is marked as @public, but its signature references "CacheManager" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "buildAccountToCache" is marked as @public, but its signature references "Authority" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "buildAccountToCache" is marked as @public, but its signature references "AccountEntity" which is marked as @internal
//
// @public (undocumented)
export function buildAccountToCache(cacheStorage: CacheManager, authority: Authority, homeAccountId: string, idTokenClaims: TokenClaims, base64Decode: (input: string) => string, clientInfo?: string, environment?: string, claimsTenantId?: string | null, authCodePayload?: AuthorizationCodePayload, nativeAccountId?: string, logger?: Logger): AccountEntity;

// @public
export function buildClientInfo(rawClientInfo: string, base64Decode: (input: string) => string): ClientInfo;

// @public
export function buildClientInfoFromHomeAccountId(homeAccountId: string): ClientInfo;

// @public (undocumented)
export function buildStaticAuthorityOptions(authOptions: Partial<AuthorityOptions>): StaticAuthorityOptions;

// @public (undocumented)
export function buildTenantProfileFromIdTokenClaims(homeAccountId: string, idTokenClaims: TokenClaims): TenantProfile;

// @public
export const CacheAccountType: {
    readonly MSSTS_ACCOUNT_TYPE: "MSSTS";
    readonly ADFS_ACCOUNT_TYPE: "ADFS";
    readonly MSAV1_ACCOUNT_TYPE: "MSA";
    readonly GENERIC_ACCOUNT_TYPE: "Generic";
};

// @public (undocumented)
export type CacheAccountType = (typeof CacheAccountType)[keyof typeof CacheAccountType];

// @public
export class CacheError extends Error {
    constructor(errorCode: string, errorMessage?: string);
    errorCode: string;
    errorMessage: string;
}

declare namespace CacheErrorCodes {
    export {
        cacheQuotaExceededErrorCode,
        cacheUnknownErrorCode
    }
}
export { CacheErrorCodes }

declare namespace CacheHelpers {
    export {
        generateCredentialKey,
        createIdTokenEntity,
        createAccessTokenEntity,
        createRefreshTokenEntity,
        isCredentialEntity,
        isAccessTokenEntity,
        isIdTokenEntity,
        isRefreshTokenEntity,
        isServerTelemetryEntity,
        isThrottlingEntity,
        generateAppMetadataKey,
        isAppMetadataEntity,
        isAuthorityMetadataEntity,
        generateAuthorityMetadataExpiresAt,
        updateAuthorityEndpointMetadata,
        updateCloudDiscoveryMetadata,
        isAuthorityMetadataExpired
    }
}
export { CacheHelpers }

// Warning: (ae-internal-missing-underscore) The name "CacheManager" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export abstract class CacheManager implements ICacheManager {
    constructor(clientId: string, cryptoImpl: ICrypto, logger: Logger, staticAuthorityOptions?: StaticAuthorityOptions);
    accessTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter, keyMustContainAllScopes: boolean): boolean;
    abstract clear(): Promise<void>;
    // (undocumented)
    protected clientId: string;
    credentialMatchesFilter(entity: ValidCredentialType, filter: CredentialFilter): boolean;
    // (undocumented)
    protected cryptoImpl: ICrypto;
    generateAuthorityMetadataCacheKey(authority: string): string;
    getAccessToken(account: AccountInfo, request: BaseAuthRequest, tokenKeys?: TokenKeys, targetRealm?: string, performanceClient?: IPerformanceClient, correlationId?: string): AccessTokenEntity | null;
    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;
    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[];
    abstract getAccount(accountKey: string, logger?: Logger): AccountEntity | null;
    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null;
    abstract getAccountKeys(): string[];
    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[];
    getAllAccounts(accountFilter?: AccountFilter): AccountInfo[];
    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;
    // Warning: (ae-forgotten-export) The symbol "AppMetadataFilter" needs to be exported by the entry point index.d.ts
    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache;
    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;
    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null;
    // (undocumented)
    abstract getAuthorityMetadataKeys(): Array<string>;
    getBaseAccountInfo(accountFilter: AccountFilter): AccountInfo | null;
    abstract getCachedAccountEntity(accountKey: string): AccountEntity | null;
    getIdToken(account: AccountInfo, tokenKeys?: TokenKeys, targetRealm?: string, performanceClient?: IPerformanceClient, correlationId?: string): IdTokenEntity | null;
    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;
    getIdTokensByFilter(filter: CredentialFilter, tokenKeys?: TokenKeys): Map<string, IdTokenEntity>;
    abstract getKeys(): string[];
    getRefreshToken(account: AccountInfo, familyRT: boolean, tokenKeys?: TokenKeys, performanceClient?: IPerformanceClient, correlationId?: string): RefreshTokenEntity | null;
    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;
    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;
    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;
    abstract getTokenKeys(): TokenKeys;
    idTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean;
    isAccountKey(key: string, homeAccountId?: string, tenantId?: string): boolean;
    isAppMetadataFOCI(environment: string): boolean;
    protected isAuthorityMetadata(key: string): boolean;
    isCredentialKey(key: string): boolean;
    readAccountFromCache(account: AccountInfo): AccountEntity | null;
    readAppMetadataFromCache(environment: string): AppMetadataEntity | null;
    refreshTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean;
    removeAccessToken(key: string): Promise<void>;
    removeAccount(accountKey: string): Promise<void>;
    removeAccountContext(account: AccountEntity): Promise<void>;
    removeAllAccounts(): Promise<void>;
    removeAppMetadata(): boolean;
    removeIdToken(key: string): void;
    abstract removeItem(key: string): void;
    abstract removeOutdatedAccount(accountKey: string): void;
    removeRefreshToken(key: string): void;
    saveCacheRecord(cacheRecord: CacheRecord, storeInCache?: StoreInCache, correlationId?: string): Promise<void>;
    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;
    abstract setAccount(account: AccountEntity): void;
    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;
    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;
    abstract setIdTokenCredential(idToken: IdTokenEntity): void;
    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;
    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;
    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;
    static toObject<T>(obj: T, json: object): T;
    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;
    protected updateOutdatedCachedAccount(accountKey: string, accountEntity: AccountEntity | null, logger?: Logger): AccountEntity | null;
}

// @public
export type CacheOptions = {
    claimsBasedCachingEnabled?: boolean;
};

// @public
export const CacheOutcome: {
    readonly NOT_APPLICABLE: "0";
    readonly FORCE_REFRESH_OR_CLAIMS: "1";
    readonly NO_CACHED_ACCESS_TOKEN: "2";
    readonly CACHED_ACCESS_TOKEN_EXPIRED: "3";
    readonly PROACTIVELY_REFRESHED: "4";
};

// @public (undocumented)
export type CacheOutcome = (typeof CacheOutcome)[keyof typeof CacheOutcome];

// @public (undocumented)
const cacheQuotaExceededErrorCode = "cache_quota_exceeded";

// Warning: (ae-internal-missing-underscore) The name "CacheRecord" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class CacheRecord {
    constructor(accountEntity?: AccountEntity | null, idTokenEntity?: IdTokenEntity | null, accessTokenEntity?: AccessTokenEntity | null, refreshTokenEntity?: RefreshTokenEntity | null, appMetadataEntity?: AppMetadataEntity | null);
    // (undocumented)
    accessToken: AccessTokenEntity | null;
    // (undocumented)
    account: AccountEntity | null;
    // (undocumented)
    appMetadata: AppMetadataEntity | null;
    // (undocumented)
    idToken: IdTokenEntity | null;
    // (undocumented)
    refreshToken: RefreshTokenEntity | null;
}

// @public
export const CacheType: {
    readonly ADFS: 1001;
    readonly MSA: 1002;
    readonly MSSTS: 1003;
    readonly GENERIC: 1004;
    readonly ACCESS_TOKEN: 2001;
    readonly REFRESH_TOKEN: 2002;
    readonly ID_TOKEN: 2003;
    readonly APP_METADATA: 3001;
    readonly UNDEFINED: 9999;
};

// @public (undocumented)
export type CacheType = (typeof CacheType)[keyof typeof CacheType];

// @public (undocumented)
const cacheUnknownErrorCode = "cache_error_unknown";

// @public (undocumented)
const cannotAllowNativeBroker = "cannot_allow_native_broker";

// @public (undocumented)
const cannotAppendScopeSet = "cannot_append_scopeset";

// @public (undocumented)
const cannotRemoveEmptyScope = "cannot_remove_empty_scope";

// @public (undocumented)
const cannotSetOIDCOptions = "cannot_set_OIDCOptions";

// @public (undocumented)
const CCS_HEADER = "X-AnchorMailbox";

// @public (undocumented)
export type CcsCredential = {
    credential: string;
    type: CcsCredentialType;
};

// @public (undocumented)
export const CcsCredentialType: {
    readonly HOME_ACCOUNT_ID: "home_account_id";
    readonly UPN: "UPN";
};

// @public (undocumented)
export type CcsCredentialType = (typeof CcsCredentialType)[keyof typeof CcsCredentialType];

// @public
function checkMaxAge(authTime: number, maxAge: number): void;

// @public (undocumented)
const CLAIMS = "claims";

// @public
export const ClaimsRequestKeys: {
    readonly ACCESS_TOKEN: "access_token";
    readonly XMS_CC: "xms_cc";
};

// @public (undocumented)
export type ClaimsRequestKeys = (typeof ClaimsRequestKeys)[keyof typeof ClaimsRequestKeys];

// @public (undocumented)
const claimsRequestParsingError = "claims_request_parsing_error";

// @public (undocumented)
const CLIENT_ASSERTION = "client_assertion";

// @public (undocumented)
const CLIENT_ASSERTION_TYPE = "client_assertion_type";

// @public (undocumented)
const CLIENT_ID = "client_id";

// @public (undocumented)
const CLIENT_INFO = "client_info";

// @public (undocumented)
const CLIENT_REQUEST_ID = "client-request-id";

// @public (undocumented)
const CLIENT_SECRET = "client_secret";

// @public
export type ClientAssertion = {
    assertion: string;
    assertionType: string;
};

// @public
export class ClientAuthError extends AuthError {
    constructor(errorCode: string, additionalMessage?: string);
}

declare namespace ClientAuthErrorCodes {
    export {
        clientInfoDecodingError,
        clientInfoEmptyError,
        tokenParsingError,
        nullOrEmptyToken,
        endpointResolutionError,
        networkError,
        openIdConfigError,
        hashNotDeserialized,
        invalidState,
        stateMismatch,
        stateNotFound,
        nonceMismatch,
        authTimeNotFound,
        maxAgeTranspired,
        multipleMatchingTokens,
        multipleMatchingAccounts,
        multipleMatchingAppMetadata,
        requestCannotBeMade,
        cannotRemoveEmptyScope,
        cannotAppendScopeSet,
        emptyInputScopeSet,
        deviceCodePollingCancelled,
        deviceCodeExpired,
        deviceCodeUnknownError,
        noAccountInSilentRequest,
        invalidCacheRecord,
        invalidCacheEnvironment,
        noAccountFound,
        noCryptoObject,
        unexpectedCredentialType,
        invalidAssertion,
        invalidClientCredential,
        tokenRefreshRequired,
        userTimeoutReached,
        tokenClaimsCnfRequiredForSignedJwt,
        authorizationCodeMissingFromServerResponse,
        bindingKeyNotRemoved,
        endSessionEndpointNotSupported,
        keyIdMissing,
        noNetworkConnectivity,
        userCanceled,
        missingTenantIdError,
        methodNotImplemented,
        nestedAppAuthBridgeDisabled
    }
}
export { ClientAuthErrorCodes }

// @public @deprecated
export const ClientAuthErrorMessage: {
    clientInfoDecodingError: {
        code: string;
        desc: string;
    };
    clientInfoEmptyError: {
        code: string;
        desc: string;
    };
    tokenParsingError: {
        code: string;
        desc: string;
    };
    nullOrEmptyToken: {
        code: string;
        desc: string;
    };
    endpointResolutionError: {
        code: string;
        desc: string;
    };
    networkError: {
        code: string;
        desc: string;
    };
    unableToGetOpenidConfigError: {
        code: string;
        desc: string;
    };
    hashNotDeserialized: {
        code: string;
        desc: string;
    };
    invalidStateError: {
        code: string;
        desc: string;
    };
    stateMismatchError: {
        code: string;
        desc: string;
    };
    stateNotFoundError: {
        code: string;
        desc: string;
    };
    nonceMismatchError: {
        code: string;
        desc: string;
    };
    authTimeNotFoundError: {
        code: string;
        desc: string;
    };
    maxAgeTranspired: {
        code: string;
        desc: string;
    };
    multipleMatchingTokens: {
        code: string;
        desc: string;
    };
    multipleMatchingAccounts: {
        code: string;
        desc: string;
    };
    multipleMatchingAppMetadata: {
        code: string;
        desc: string;
    };
    tokenRequestCannotBeMade: {
        code: string;
        desc: string;
    };
    removeEmptyScopeError: {
        code: string;
        desc: string;
    };
    appendScopeSetError: {
        code: string;
        desc: string;
    };
    emptyInputScopeSetError: {
        code: string;
        desc: string;
    };
    DeviceCodePollingCancelled: {
        code: string;
        desc: string;
    };
    DeviceCodeExpired: {
        code: string;
        desc: string;
    };
    DeviceCodeUnknownError: {
        code: string;
        desc: string;
    };
    NoAccountInSilentRequest: {
        code: string;
        desc: string;
    };
    invalidCacheRecord: {
        code: string;
        desc: string;
    };
    invalidCacheEnvironment: {
        code: string;
        desc: string;
    };
    noAccountFound: {
        code: string;
        desc: string;
    };
    noCryptoObj: {
        code: string;
        desc: string;
    };
    unexpectedCredentialType: {
        code: string;
        desc: string;
    };
    invalidAssertion: {
        code: string;
        desc: string;
    };
    invalidClientCredential: {
        code: string;
        desc: string;
    };
    tokenRefreshRequired: {
        code: string;
        desc: string;
    };
    userTimeoutReached: {
        code: string;
        desc: string;
    };
    tokenClaimsRequired: {
        code: string;
        desc: string;
    };
    noAuthorizationCodeFromServer: {
        code: string;
        desc: string;
    };
    bindingKeyNotRemovedError: {
        code: string;
        desc: string;
    };
    logoutNotSupported: {
        code: string;
        desc: string;
    };
    keyIdMissing: {
        code: string;
        desc: string;
    };
    noNetworkConnectivity: {
        code: string;
        desc: string;
    };
    userCanceledError: {
        code: string;
        desc: string;
    };
    missingTenantIdError: {
        code: string;
        desc: string;
    };
    nestedAppAuthBridgeDisabled: {
        code: string;
        desc: string;
    };
};

// Warning: (ae-internal-missing-underscore) The name "ClientConfiguration" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type ClientConfiguration = {
    authOptions: AuthOptions;
    systemOptions?: SystemOptions;
    loggerOptions?: LoggerOptions;
    cacheOptions?: CacheOptions;
    storageInterface?: CacheManager;
    networkInterface?: INetworkModule;
    cryptoInterface?: ICrypto;
    clientCredentials?: ClientCredentials;
    libraryInfo?: LibraryInfo;
    telemetry?: TelemetryOptions;
    serverTelemetryManager?: ServerTelemetryManager | null;
    persistencePlugin?: ICachePlugin | null;
    serializableCache?: ISerializableTokenCache | null;
};

// @public
export class ClientConfigurationError extends AuthError {
    constructor(errorCode: string);
}

declare namespace ClientConfigurationErrorCodes {
    export {
        redirectUriEmpty,
        claimsRequestParsingError,
        authorityUriInsecure,
        urlParseError,
        urlEmptyError,
        emptyInputScopesError,
        invalidPromptValue,
        invalidClaims,
        tokenRequestEmpty,
        logoutRequestEmpty,
        invalidCodeChallengeMethod,
        pkceParamsMissing,
        invalidCloudDiscoveryMetadata,
        invalidAuthorityMetadata,
        untrustedAuthority,
        missingSshJwk,
        missingSshKid,
        missingNonceAuthenticationHeader,
        invalidAuthenticationHeader,
        cannotSetOIDCOptions,
        cannotAllowNativeBroker,
        authorityMismatch
    }
}
export { ClientConfigurationErrorCodes }

// @public @deprecated
export const ClientConfigurationErrorMessage: {
    redirectUriNotSet: {
        code: string;
        desc: string;
    };
    claimsRequestParsingError: {
        code: string;
        desc: string;
    };
    authorityUriInsecure: {
        code: string;
        desc: string;
    };
    urlParseError: {
        code: string;
        desc: string;
    };
    urlEmptyError: {
        code: string;
        desc: string;
    };
    emptyScopesError: {
        code: string;
        desc: string;
    };
    invalidPrompt: {
        code: string;
        desc: string;
    };
    invalidClaimsRequest: {
        code: string;
        desc: string;
    };
    tokenRequestEmptyError: {
        code: string;
        desc: string;
    };
    logoutRequestEmptyError: {
        code: string;
        desc: string;
    };
    invalidCodeChallengeMethod: {
        code: string;
        desc: string;
    };
    invalidCodeChallengeParams: {
        code: string;
        desc: string;
    };
    invalidCloudDiscoveryMetadata: {
        code: string;
        desc: string;
    };
    invalidAuthorityMetadata: {
        code: string;
        desc: string;
    };
    untrustedAuthority: {
        code: string;
        desc: string;
    };
    missingSshJwk: {
        code: string;
        desc: string;
    };
    missingSshKid: {
        code: string;
        desc: string;
    };
    missingNonceAuthenticationHeader: {
        code: string;
        desc: string;
    };
    invalidAuthenticationHeader: {
        code: string;
        desc: string;
    };
    cannotSetOIDCOptions: {
        code: string;
        desc: string;
    };
    cannotAllowNativeBroker: {
        code: string;
        desc: string;
    };
    authorityMismatch: {
        code: string;
        desc: string;
    };
};

// @public
export type ClientInfo = {
    uid: string;
    utid: string;
};

// @public (undocumented)
const clientInfoDecodingError = "client_info_decoding_error";

// @public (undocumented)
const clientInfoEmptyError = "client_info_empty_error";

// @public (undocumented)
const CODE = "code";

// @public (undocumented)
const CODE_CHALLENGE = "code_challenge";

// @public (undocumented)
const CODE_CHALLENGE_METHOD = "code_challenge_method";

// @public (undocumented)
const CODE_VERIFIER = "code_verifier";

// @public
export const CodeChallengeMethodValues: {
    PLAIN: string;
    S256: string;
};

// @public
export type CommonAuthorizationCodeRequest = BaseAuthRequest & {
    code: string;
    redirectUri: string;
    codeVerifier?: string;
    tokenBodyParameters?: StringDict;
    enableSpaAuthorizationCode?: boolean;
    clientInfo?: string;
    ccsCredential?: CcsCredential;
};

// @public
export type CommonAuthorizationUrlRequest = BaseAuthRequest & {
    redirectUri: string;
    responseMode: ResponseMode;
    account?: AccountInfo;
    codeChallenge?: string;
    codeChallengeMethod?: string;
    domainHint?: string;
    extraQueryParameters?: StringDict;
    extraScopesToConsent?: Array<string>;
    loginHint?: string;
    nonce?: string;
    prompt?: string;
    sid?: string;
    state?: string;
    nativeBroker?: boolean;
};

// @public
export type CommonClientCredentialRequest = BaseAuthRequest & {
    skipCache?: boolean;
    azureRegion?: AzureRegion;
    clientAssertion?: ClientAssertion;
};

// @public
export type CommonDeviceCodeRequest = Omit<BaseAuthRequest, "tokenQueryParameters"> & {
    deviceCodeCallback: (response: DeviceCodeResponse) => void;
    cancel?: boolean;
    timeout?: number;
    extraQueryParameters?: StringDict;
};

// @public
export type CommonEndSessionRequest = {
    correlationId: string;
    account?: AccountInfo | null;
    postLogoutRedirectUri?: string | null;
    idTokenHint?: string;
    state?: string;
    logoutHint?: string;
    extraQueryParameters?: StringDict;
};

// @public
export type CommonOnBehalfOfRequest = BaseAuthRequest & {
    oboAssertion: string;
    skipCache?: boolean;
};

// @public
export type CommonRefreshTokenRequest = BaseAuthRequest & {
    refreshToken: string;
    ccsCredential?: CcsCredential;
    forceCache?: boolean;
    tokenBodyParameters?: StringDict;
    redirectUri?: string;
};

// @public
export type CommonSilentFlowRequest = BaseAuthRequest & {
    account: AccountInfo;
    forceRefresh: boolean;
    redirectUri?: string;
    tokenBodyParameters?: StringDict;
    refreshTokenExpirationOffsetSeconds?: number;
};

// @public
export type CommonUsernamePasswordRequest = BaseAuthRequest & {
    username: string;
    password: string;
};

// @public (undocumented)
const consentRequired = "consent_required";

// @public (undocumented)
export const Constants: {
    LIBRARY_NAME: string;
    SKU: string;
    CACHE_PREFIX: string;
    DEFAULT_AUTHORITY: string;
    DEFAULT_AUTHORITY_HOST: string;
    DEFAULT_COMMON_TENANT: string;
    ADFS: string;
    DSTS: string;
    AAD_INSTANCE_DISCOVERY_ENDPT: string;
    CIAM_AUTH_URL: string;
    AAD_TENANT_DOMAIN_SUFFIX: string;
    RESOURCE_DELIM: string;
    NO_ACCOUNT: string;
    CLAIMS: string;
    CONSUMER_UTID: string;
    OPENID_SCOPE: string;
    PROFILE_SCOPE: string;
    OFFLINE_ACCESS_SCOPE: string;
    EMAIL_SCOPE: string;
    CODE_RESPONSE_TYPE: string;
    CODE_GRANT_TYPE: string;
    RT_GRANT_TYPE: string;
    FRAGMENT_RESPONSE_MODE: string;
    S256_CODE_CHALLENGE_METHOD: string;
    URL_FORM_CONTENT_TYPE: string;
    AUTHORIZATION_PENDING: string;
    NOT_DEFINED: string;
    EMPTY_STRING: string;
    NOT_APPLICABLE: string;
    FORWARD_SLASH: string;
    IMDS_ENDPOINT: string;
    IMDS_VERSION: string;
    IMDS_TIMEOUT: number;
    AZURE_REGION_AUTO_DISCOVER_FLAG: string;
    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: string;
    KNOWN_PUBLIC_CLOUDS: string[];
    TOKEN_RESPONSE_TYPE: string;
    ID_TOKEN_RESPONSE_TYPE: string;
    SHR_NONCE_VALIDITY: number;
    INVALID_INSTANCE: string;
};

// @public
function createAccessTokenEntity(homeAccountId: string, environment: string, accessToken: string, clientId: string, tenantId: string, scopes: string, expiresOn: number, extExpiresOn: number, base64Decode: (input: string) => string, refreshOn?: number, tokenType?: AuthenticationScheme, userAssertionHash?: string, keyId?: string, requestedClaims?: string, requestedClaimsHash?: string): AccessTokenEntity;

// @public (undocumented)
export function createAuthError(code: string, additionalMessage?: string): AuthError;

// @public (undocumented)
export function createClientAuthError(errorCode: string, additionalMessage?: string): ClientAuthError;

// @public (undocumented)
export function createClientConfigurationError(errorCode: string): ClientConfigurationError;

// @internal
function createDiscoveredInstance(authorityUri: string, networkClient: INetworkModule, cacheManager: ICacheManager, authorityOptions: AuthorityOptions, logger: Logger, correlationId: string, performanceClient?: IPerformanceClient): Promise<Authority>;

// @public
function createIdTokenEntity(homeAccountId: string, environment: string, idToken: string, clientId: string, tenantId: string): IdTokenEntity;

// @public
export function createInteractionRequiredAuthError(errorCode: string): InteractionRequiredAuthError;

// @public
function createRefreshTokenEntity(homeAccountId: string, environment: string, refreshToken: string, clientId: string, familyId?: string, userAssertionHash?: string, expiresOn?: number): RefreshTokenEntity;

// @public
export type CredentialEntity = {
    homeAccountId: string;
    environment: string;
    credentialType: CredentialType;
    clientId: string;
    secret: string;
    familyId?: string;
    realm?: string;
    target?: string;
    userAssertionHash?: string;
    tokenType?: AuthenticationScheme;
    keyId?: string;
    requestedClaimsHash?: string;
};

// @public
export type CredentialFilter = {
    homeAccountId?: string;
    environment?: string;
    credentialType?: string;
    clientId?: string;
    familyId?: string;
    realm?: string;
    target?: ScopeSet;
    userAssertionHash?: string;
    tokenType?: AuthenticationScheme;
    keyId?: string;
    requestedClaimsHash?: string;
};

// @public
export const CredentialType: {
    readonly ID_TOKEN: "IdToken";
    readonly ACCESS_TOKEN: "AccessToken";
    readonly ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme";
    readonly REFRESH_TOKEN: "RefreshToken";
};

// @public (undocumented)
export type CredentialType = (typeof CredentialType)[keyof typeof CredentialType];

// @public (undocumented)
export const DEFAULT_CRYPTO_IMPLEMENTATION: ICrypto;

// @public (undocumented)
export const DEFAULT_SYSTEM_OPTIONS: Required<SystemOptions>;

// @public (undocumented)
export const DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;

// Warning: (ae-internal-missing-underscore) The name "DefaultStorageClass" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class DefaultStorageClass extends CacheManager {
    // (undocumented)
    clear(): Promise<void>;
    // (undocumented)
    getAccessTokenCredential(): AccessTokenEntity;
    // (undocumented)
    getAccount(): AccountEntity;
    // (undocumented)
    getAccountKeys(): string[];
    // (undocumented)
    getAppMetadata(): AppMetadataEntity;
    // (undocumented)
    getAuthorityMetadata(): AuthorityMetadataEntity | null;
    // (undocumented)
    getAuthorityMetadataKeys(): Array<string>;
    // (undocumented)
    getCachedAccountEntity(): AccountEntity | null;
    // (undocumented)
    getIdTokenCredential(): IdTokenEntity;
    // (undocumented)
    getKeys(): string[];
    // (undocumented)
    getRefreshTokenCredential(): RefreshTokenEntity;
    // (undocumented)
    getServerTelemetry(): ServerTelemetryEntity;
    // (undocumented)
    getThrottlingCache(): ThrottlingEntity;
    // (undocumented)
    getTokenKeys(): TokenKeys;
    // (undocumented)
    removeItem(): boolean;
    // (undocumented)
    removeOutdatedAccount(): void;
    // (undocumented)
    setAccessTokenCredential(): void;
    // (undocumented)
    setAccount(): void;
    // (undocumented)
    setAppMetadata(): void;
    // (undocumented)
    setAuthorityMetadata(): void;
    // (undocumented)
    setIdTokenCredential(): void;
    // (undocumented)
    setRefreshTokenCredential(): void;
    // (undocumented)
    setServerTelemetry(): void;
    // (undocumented)
    setThrottlingCache(): void;
    // (undocumented)
    updateCredentialCacheKey(): string;
}

// @public
function delay<T>(t: number, value?: T): Promise<T | void>;

// @public (undocumented)
const DEVICE_CODE = "device_code";

// @public (undocumented)
const deviceCodeExpired = "device_code_expired";

// @public (undocumented)
const deviceCodePollingCancelled = "device_code_polling_cancelled";

// @public
export type DeviceCodeResponse = {
    userCode: string;
    deviceCode: string;
    verificationUri: string;
    expiresIn: number;
    interval: number;
    message: string;
};

// @public (undocumented)
const deviceCodeUnknownError = "device_code_unknown_error";

// @public (undocumented)
const DOMAIN_HINT = "domain_hint";

// @public (undocumented)
const emptyInputScopesError = "empty_input_scopes_error";

// @public (undocumented)
const emptyInputScopeSet = "empty_input_scopeset";

// @public (undocumented)
const endpointResolutionError = "endpoints_resolution_error";

// @public (undocumented)
const endSessionEndpointNotSupported = "end_session_endpoint_not_supported";

// @public (undocumented)
const ERROR = "error";

// @public (undocumented)
const ERROR_DESCRIPTION = "error_description";

// @public (undocumented)
export const Errors: {
    INVALID_GRANT_ERROR: string;
    CLIENT_MISMATCH_ERROR: string;
};

// @public (undocumented)
const EXPIRES_IN = "expires_in";

// @public
export type ExternalTokenResponse = Pick<ServerAuthorizationTokenResponse, "token_type" | "scope" | "expires_in" | "id_token" | "refresh_token"> & {
    access_token?: string;
    client_info?: string;
};

// @public
function extractTokenClaims(encodedToken: string, base64Decode: (input: string) => string): TokenClaims;

// @public (undocumented)
const FOCI = "foci";

// @public (undocumented)
export function formatAuthorityUri(authorityUri: string): string;

// @public
function generateAppMetadataKey({ environment, clientId, }: AppMetadataEntity): string;

// @public
function generateAuthorityMetadataExpiresAt(): number;

// @public
function generateCredentialKey(credentialEntity: CredentialEntity): string;

// @public
function getDeserializedResponse(responseString: string): ServerAuthorizationCodeResponse | null;

// @public
function getJWSPayload(authToken: string): string;

// @public
export function getTenantIdFromIdTokenClaims(idTokenClaims?: TokenClaims): string | null;

// @public (undocumented)
const GRANT_TYPE = "grant_type";

// @public
export const GrantType: {
    readonly IMPLICIT_GRANT: "implicit";
    readonly AUTHORIZATION_CODE_GRANT: "authorization_code";
    readonly CLIENT_CREDENTIALS_GRANT: "client_credentials";
    readonly RESOURCE_OWNER_PASSWORD_GRANT: "password";
    readonly REFRESH_TOKEN_GRANT: "refresh_token";
    readonly DEVICE_CODE_GRANT: "device_code";
    readonly JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer";
};

// @public (undocumented)
export type GrantType = (typeof GrantType)[keyof typeof GrantType];

// @public (undocumented)
const hashNotDeserialized = "hash_not_deserialized";

// @public
export const HeaderNames: {
    readonly CONTENT_TYPE: "Content-Type";
    readonly RETRY_AFTER: "Retry-After";
    readonly CCS_HEADER: "X-AnchorMailbox";
    readonly WWWAuthenticate: "WWW-Authenticate";
    readonly AuthenticationInfo: "Authentication-Info";
    readonly X_MS_REQUEST_ID: "x-ms-request-id";
    readonly X_MS_HTTP_VERSION: "x-ms-httpver";
};

// @public (undocumented)
export type HeaderNames = (typeof HeaderNames)[keyof typeof HeaderNames];

// @public (undocumented)
export const HttpStatus: {
    readonly SUCCESS: 200;
    readonly SUCCESS_RANGE_START: 200;
    readonly SUCCESS_RANGE_END: 299;
    readonly REDIRECT: 302;
    readonly CLIENT_ERROR: 400;
    readonly CLIENT_ERROR_RANGE_START: 400;
    readonly BAD_REQUEST: 400;
    readonly UNAUTHORIZED: 401;
    readonly NOT_FOUND: 404;
    readonly REQUEST_TIMEOUT: 408;
    readonly TOO_MANY_REQUESTS: 429;
    readonly CLIENT_ERROR_RANGE_END: 499;
    readonly SERVER_ERROR: 500;
    readonly SERVER_ERROR_RANGE_START: 500;
    readonly SERVICE_UNAVAILABLE: 503;
    readonly GATEWAY_TIMEOUT: 504;
    readonly SERVER_ERROR_RANGE_END: 599;
    readonly MULTI_SIDED_ERROR: 600;
};

// @public (undocumented)
export type HttpStatus = (typeof HttpStatus)[keyof typeof HttpStatus];

// @public
export interface IAppTokenProvider {
    // (undocumented)
    (appTokenProviderParameters: AppTokenProviderParameters): Promise<AppTokenProviderResult>;
}

// @public (undocumented)
export interface ICachePlugin {
    // (undocumented)
    afterCacheAccess: (tokenCacheContext: TokenCacheContext) => Promise<void>;
    // (undocumented)
    beforeCacheAccess: (tokenCacheContext: TokenCacheContext) => Promise<void>;
}

// @public
export interface ICrypto {
    base64Decode(input: string): string;
    base64Encode(input: string): string;
    clearKeystore(): Promise<boolean>;
    createNewGuid(): string;
    getPublicKeyThumbprint(request: SignedHttpRequestParameters): Promise<string>;
    hashString(plainText: string): Promise<string>;
    removeTokenBindingKey(kid: string): Promise<boolean>;
    signJwt(payload: SignedHttpRequest, kid: string, shrOptions?: ShrOptions, correlationId?: string): Promise<string>;
}

// @public (undocumented)
const ID_TOKEN = "id_token";

// @public (undocumented)
const ID_TOKEN_HINT = "id_token_hint";

// Warning: (ae-internal-missing-underscore) The name "IdTokenCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type IdTokenCache = Record<string, IdTokenEntity>;

// @public
export type IdTokenEntity = CredentialEntity & {
    realm: string;
};

// @public (undocumented)
export interface IGuidGenerator {
    // (undocumented)
    generateGuid(): string;
    // (undocumented)
    isGuid(guid: string): boolean;
}

// @public
export interface ILoggerCallback {
    // (undocumented)
    (level: LogLevel, message: string, containsPii: boolean): void;
}

// @public (undocumented)
export interface INativeBrokerPlugin {
    // (undocumented)
    acquireTokenInteractive(request: NativeRequest, windowHandle?: Buffer): Promise<AuthenticationResult>;
    // (undocumented)
    acquireTokenSilent(request: NativeRequest): Promise<AuthenticationResult>;
    // (undocumented)
    getAccountById(accountId: string, correlationId: string): Promise<AccountInfo>;
    // (undocumented)
    getAllAccounts(clientId: string, correlationId: string): Promise<AccountInfo[]>;
    // (undocumented)
    isBrokerAvailable: boolean;
    // (undocumented)
    setLogger(loggerOptions: LoggerOptions): void;
    // (undocumented)
    signOut(request: NativeSignOutRequest): Promise<void>;
}

// @public
export interface INetworkModule {
    sendGetRequestAsync<T>(url: string, options?: NetworkRequestOptions, timeout?: number): Promise<NetworkResponse<T>>;
    sendPostRequestAsync<T>(url: string, options?: NetworkRequestOptions): Promise<NetworkResponse<T>>;
}

// @public (undocumented)
export type InProgressPerformanceEvent = {
    end: (event?: Partial<PerformanceEvent>, error?: unknown) => PerformanceEvent | null;
    discard: () => void;
    add: (fields: {
        [key: string]: {} | undefined;
    }) => void;
    increment: (fields: {
        [key: string]: number | undefined;
    }) => void;
    event: PerformanceEvent;
    measurement: IPerformanceMeasurement;
};

// @public (undocumented)
const interactionRequired = "interaction_required";

// @public
export class InteractionRequiredAuthError extends AuthError {
    constructor(errorCode?: string, errorMessage?: string, subError?: string, timestamp?: string, traceId?: string, correlationId?: string, claims?: string, errorNo?: string);
    claims: string;
    readonly errorNo?: string;
    timestamp: string;
    traceId: string;
}

declare namespace InteractionRequiredAuthErrorCodes {
    export {
        noTokensFound,
        nativeAccountUnavailable,
        refreshTokenExpired,
        interactionRequired,
        consentRequired,
        loginRequired,
        badToken
    }
}
export { InteractionRequiredAuthErrorCodes }

// @public @deprecated
export const InteractionRequiredAuthErrorMessage: {
    noTokensFoundError: {
        code: string;
        desc: string;
    };
    native_account_unavailable: {
        code: string;
        desc: string;
    };
    bad_token: {
        code: string;
        desc: string;
    };
};

// @public (undocumented)
export const IntFields: ReadonlySet<string>;

// @public (undocumented)
const invalidAssertion = "invalid_assertion";

// @public (undocumented)
const invalidAuthenticationHeader = "invalid_authentication_header";

// @public (undocumented)
const invalidAuthorityMetadata = "invalid_authority_metadata";

// @public (undocumented)
const invalidCacheEnvironment = "invalid_cache_environment";

// @public (undocumented)
const invalidCacheRecord = "invalid_cache_record";

// @public (undocumented)
const invalidClaims = "invalid_claims";

// @public (undocumented)
const invalidClientCredential = "invalid_client_credential";

// @public (undocumented)
const invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";

// @public (undocumented)
const invalidCodeChallengeMethod = "invalid_code_challenge_method";

// @public (undocumented)
const invalidPromptValue = "invalid_prompt_value";

// @public (undocumented)
const invalidState = "invalid_state";

// Warning: (ae-internal-missing-underscore) The name "invoke" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const invoke: <T extends any[], U>(callback: (...args: T) => U, eventName: string, logger: Logger, telemetryClient?: IPerformanceClient, correlationId?: string) => (...args: T) => U;

// Warning: (ae-internal-missing-underscore) The name "invokeAsync" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const invokeAsync: <T extends any[], U>(callback: (...args: T) => Promise<U>, eventName: string, logger: Logger, telemetryClient?: IPerformanceClient, correlationId?: string) => (...args: T) => Promise<U>;

// @public (undocumented)
export interface IPerformanceClient {
    // (undocumented)
    addFields(fields: {
        [key: string]: {} | undefined;
    }, correlationId: string): void;
    // (undocumented)
    addPerformanceCallback(callback: PerformanceCallbackFunction): string;
    // (undocumented)
    addQueueMeasurement(eventName: string, correlationId?: string, queueTime?: number, manuallyCompleted?: boolean): void;
    // (undocumented)
    calculateQueuedTime(preQueueTime: number, currentTime: number): number;
    // (undocumented)
    discardMeasurements(correlationId: string): void;
    // (undocumented)
    emitEvents(events: PerformanceEvent[], correlationId: string): void;
    // (undocumented)
    endMeasurement(event: PerformanceEvent): PerformanceEvent | null;
    // (undocumented)
    generateId(): string;
    // (undocumented)
    incrementFields(fields: {
        [key: string]: number | undefined;
    }, correlationId: string): void;
    // (undocumented)
    removePerformanceCallback(callbackId: string): boolean;
    // (undocumented)
    setPreQueueTime(eventName: string, correlationId?: string): void;
    // (undocumented)
    startMeasurement(measureName: string, correlationId?: string): InProgressPerformanceEvent;
    // @deprecated (undocumented)
    startPerformanceMeasurement(measureName: string, correlationId: string): IPerformanceMeasurement;
}

// @public (undocumented)
export interface IPerformanceMeasurement {
    // (undocumented)
    endMeasurement(): void;
    // (undocumented)
    flushMeasurement(): number | null;
    // (undocumented)
    startMeasurement(): void;
}

// @public
function isAccessTokenEntity(entity: object): boolean;

// @public (undocumented)
function isAppMetadataEntity(key: string, entity: object): boolean;

// @public
function isAuthorityMetadataEntity(key: string, entity: object): boolean;

// Warning: (ae-incompatible-release-tags) The symbol "isAuthorityMetadataExpired" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "isAuthorityMetadataExpired" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
//
// @public
function isAuthorityMetadataExpired(metadata: AuthorityMetadataEntity): boolean;

// @public (undocumented)
function isCredentialEntity(entity: object): boolean;

// @public (undocumented)
export interface ISerializableTokenCache {
    // (undocumented)
    deserialize: (cache: string) => void;
    // (undocumented)
    serialize: () => string;
}

// @public
function isIdTokenEntity(entity: object): boolean;

// @public
function isRefreshTokenEntity(entity: object): boolean;

// @public
function isServerTelemetryEntity(key: string, entity?: object): boolean;

// @public
function isThrottlingEntity(key: string, entity?: object): boolean;

// @public
function isTokenExpired(expiresOn: string, offset: number): boolean;

// @public
export interface IUri {
    // (undocumented)
    AbsolutePath: string;
    // (undocumented)
    Hash: string;
    // (undocumented)
    HostNameAndPort: string;
    // (undocumented)
    PathSegments: string[];
    // (undocumented)
    Protocol: string;
    // (undocumented)
    QueryString: string;
    // (undocumented)
    Search: string;
}

// Warning: (ae-internal-missing-underscore) The name "JoseHeader" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class JoseHeader {
    // Warning: (ae-forgotten-export) The symbol "JoseHeaderOptions" needs to be exported by the entry point index.d.ts
    constructor(options: JoseHeaderOptions);
    // (undocumented)
    alg?: string;
    static getShrHeaderString(shrHeaderOptions: JoseHeaderOptions): string;
    // (undocumented)
    kid?: string;
    // (undocumented)
    typ?: JsonWebTokenTypes;
}

// @public (undocumented)
export const JsonWebTokenTypes: {
    readonly Jwt: "JWT";
    readonly Jwk: "JWK";
    readonly Pop: "pop";
};

// @public (undocumented)
export type JsonWebTokenTypes = (typeof JsonWebTokenTypes)[keyof typeof JsonWebTokenTypes];

// @public (undocumented)
const keyIdMissing = "key_id_missing";

// @public
export type LibraryStateObject = {
    id: string;
    meta?: Record<string, string>;
};

// @public
export class Logger {
    constructor(loggerOptions: LoggerOptions, packageName?: string, packageVersion?: string);
    clone(packageName: string, packageVersion: string, correlationId?: string): Logger;
    error(message: string, correlationId?: string): void;
    errorPii(message: string, correlationId?: string): void;
    executeCallback(level: LogLevel, message: string, containsPii: boolean): void;
    info(message: string, correlationId?: string): void;
    infoPii(message: string, correlationId?: string): void;
    isPiiLoggingEnabled(): boolean;
    trace(message: string, correlationId?: string): void;
    tracePii(message: string, correlationId?: string): void;
    verbose(message: string, correlationId?: string): void;
    verbosePii(message: string, correlationId?: string): void;
    warning(message: string, correlationId?: string): void;
    warningPii(message: string, correlationId?: string): void;
}

// @public
export type LoggerOptions = {
    loggerCallback?: ILoggerCallback;
    piiLoggingEnabled?: boolean;
    logLevel?: LogLevel;
    correlationId?: string;
};

// @public (undocumented)
const LOGIN_HINT = "login_hint";

// @public (undocumented)
const loginRequired = "login_required";

// @public
export enum LogLevel {
    // (undocumented)
    Error = 0,
    // (undocumented)
    Info = 2,
    // (undocumented)
    Trace = 4,
    // (undocumented)
    Verbose = 3,
    // (undocumented)
    Warning = 1
}

// @public (undocumented)
const LOGOUT_HINT = "logout_hint";

// @public (undocumented)
const logoutRequestEmpty = "logout_request_empty";

// @public (undocumented)
const maxAgeTranspired = "max_age_transpired";

// @public (undocumented)
const methodNotImplemented = "method_not_implemented";

// @public (undocumented)
const missingNonceAuthenticationHeader = "missing_nonce_authentication_header";

// @public (undocumented)
const missingSshJwk = "missing_ssh_jwk";

// @public (undocumented)
const missingSshKid = "missing_ssh_kid";

// @public (undocumented)
const missingTenantIdError = "missing_tenant_id_error";

// @public (undocumented)
const multipleMatchingAccounts = "multiple_matching_accounts";

// @public (undocumented)
const multipleMatchingAppMetadata = "multiple_matching_appMetadata";

// @public (undocumented)
const multipleMatchingTokens = "multiple_matching_tokens";

// @public (undocumented)
const NATIVE_BROKER = "nativebroker";

// @public (undocumented)
const nativeAccountUnavailable = "native_account_unavailable";

// @public (undocumented)
export type NativeRequest = {
    clientId: string;
    authority: string;
    correlationId: string;
    redirectUri: string;
    scopes: Array<string>;
    claims?: string;
    authenticationScheme?: string;
    resourceRequestMethod?: string;
    resourceRequestUri?: string;
    shrNonce?: string;
    accountId?: string;
    forceRefresh?: boolean;
    extraParameters?: StringDict;
    extraScopesToConsent?: Array<string>;
    loginHint?: string;
    prompt?: string;
};

// @public (undocumented)
export type NativeSignOutRequest = {
    clientId: string;
    accountId: string;
    correlationId: string;
};

// @public (undocumented)
const nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";

// @public (undocumented)
const networkError = "network_error";

// Warning: (ae-internal-missing-underscore) The name "NetworkManager" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class NetworkManager {
    constructor(networkClient: INetworkModule, cacheManager: CacheManager);
    sendPostRequest<T extends ServerAuthorizationTokenResponse>(thumbprint: RequestThumbprint, tokenEndpoint: string, options: NetworkRequestOptions): Promise<NetworkResponse<T>>;
}

// @public
export type NetworkRequestOptions = {
    headers?: Record<string, string>;
    body?: string;
};

// @public (undocumented)
export type NetworkResponse<T> = {
    headers: Record<string, string>;
    body: T;
    status: number;
};

// @public (undocumented)
const noAccountFound = "no_account_found";

// @public (undocumented)
const noAccountInSilentRequest = "no_account_in_silent_request";

// @public (undocumented)
const noCryptoObject = "no_crypto_object";

// @public (undocumented)
const NONCE = "nonce";

// @public (undocumented)
const nonceMismatch = "nonce_mismatch";

// @public (undocumented)
const noNetworkConnectivity = "no_network_connectivity";

// @public (undocumented)
const noTokensFound = "no_tokens_found";

// @public
function nowSeconds(): number;

// @public (undocumented)
const nullOrEmptyToken = "null_or_empty_token";

// @public (undocumented)
const OBO_ASSERTION = "assertion";

// @public (undocumented)
export const OIDC_DEFAULT_SCOPES: string[];

// @public
export type OIDCOptions = {
    serverResponseType?: ServerResponseType;
    defaultScopes?: Array<string>;
};

// @public (undocumented)
const ON_BEHALF_OF = "on_behalf_of";

// @public (undocumented)
export const ONE_DAY_IN_MS = 86400000;

// @public (undocumented)
const openIdConfigError = "openid_config_error";

// @public
export const PasswordGrantConstants: {
    readonly username: "username";
    readonly password: "password";
};

// @public (undocumented)
export type PasswordGrantConstants = (typeof PasswordGrantConstants)[keyof typeof PasswordGrantConstants];

// @public (undocumented)
export type PerformanceCallbackFunction = (events: PerformanceEvent[]) => void;

// @public (undocumented)
export abstract class PerformanceClient implements IPerformanceClient {
    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry, intFields?: Set<string>, abbreviations?: Map<string, string>);
    protected abbreviations: Map<string, string>;
    addFields(fields: {
        [key: string]: {} | undefined;
    }, correlationId: string): void;
    addPerformanceCallback(callback: PerformanceCallbackFunction): string;
    addQueueMeasurement(eventName: string, correlationId?: string, queueTime?: number, manuallyCompleted?: boolean): void;
    // (undocumented)
    protected applicationTelemetry: ApplicationTelemetry;
    // (undocumented)
    protected authority: string;
    protected cacheEventByCorrelationId(event: PerformanceEvent): void;
    calculateQueuedTime(preQueueTime: number, currentTime: number): number;
    // (undocumented)
    protected callbacks: Map<string, PerformanceCallbackFunction>;
    // (undocumented)
    protected clientId: string;
    discardMeasurements(correlationId: string): void;
    emitEvents(events: PerformanceEvent[], correlationId: string): void;
    endMeasurement(event: PerformanceEvent, error?: unknown): PerformanceEvent | null;
    protected eventsByCorrelationId: Map<string, PerformanceEvent>;
    // Warning: (ae-forgotten-export) The symbol "PerformanceEventStackedContext" needs to be exported by the entry point index.d.ts
    protected eventStack: Map<string, PerformanceEventStackedContext[]>;
    abstract generateId(): string;
    getPreQueueTime(eventName: string, correlationId: string): number | void;
    incrementFields(fields: {
        [key: string]: number | undefined;
    }, correlationId: string): void;
    // (undocumented)
    protected intFields: Set<string>;
    // (undocumented)
    protected libraryName: string;
    // (undocumented)
    protected libraryVersion: string;
    // (undocumented)
    protected logger: Logger;
    protected preQueueTimeByCorrelationId: Map<string, PreQueueEvent>;
    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;
    removePerformanceCallback(callbackId: string): boolean;
    abstract setPreQueueTime(eventName: PerformanceEvents, correlationId?: string): void;
    startMeasurement(measureName: string, correlationId?: string): InProgressPerformanceEvent;
    // @deprecated
    startPerformanceMeasurement(measureName: string, // eslint-disable-line @typescript-eslint/no-unused-vars
    correlationId: string): IPerformanceMeasurement;
}

// @public
export type PerformanceEvent = {
    eventId: string;
    status: PerformanceEventStatus;
    authority: string;
    clientId: string;
    correlationId: string;
    durationMs?: number;
    endPageVisibility?: string | null;
    fromCache?: boolean | null;
    name: string;
    startPageVisibility?: string | null;
    startTimeMs: number;
    success?: boolean | null;
    errorCode?: string;
    subErrorCode?: string;
    serverErrorNo?: string;
    libraryName: string;
    libraryVersion: string;
    isNativeBroker?: boolean;
    requestId?: string;
    cacheLookupPolicy?: number | undefined;
    cacheOutcome?: number;
    queuedTimeMs?: number;
    incompleteSubMeasurements?: Map<string, SubMeasurement>;
    visibilityChangeCount?: number;
    incompleteSubsCount?: number;
    awaitIframeCorrelationId?: string;
    queuedCount?: number;
    queuedManuallyCompletedCount?: number;
    idTokenSize?: number;
    accessTokenSize?: number;
    refreshTokenSize?: number | undefined;
    appName?: string;
    appVersion?: string;
    extensionId?: string;
    extensionVersion?: string;
    matsBrokerVersion?: string;
    matsAccountJoinOnStart?: string;
    matsAccountJoinOnEnd?: string;
    matsDeviceJoin?: string;
    matsPromptBehavior?: string;
    matsApiErrorCode?: number;
    matsUiVisible?: boolean;
    matsSilentCode?: number;
    matsSilentBiSubCode?: number;
    matsSilentMessage?: string;
    matsSilentStatus?: number;
    matsHttpStatus?: number;
    matsHttpEventCount?: number;
    httpVerToken?: string;
    allowNativeBroker?: boolean;
    extensionInstalled?: boolean;
    extensionHandshakeTimeoutMs?: number;
    extensionHandshakeTimedOut?: boolean;
    nestedAppAuthRequest?: boolean;
    multiMatchedAT?: number;
    multiMatchedID?: number;
    multiMatchedRT?: number;
    errorName?: string;
    errorStack?: string[];
    context?: string;
    cacheRtCount?: number;
    cacheIdCount?: number;
    cacheAtCount?: number;
    scenarioId?: string;
    accountType?: "AAD" | "MSA" | "B2C";
};

// @public
export const PerformanceEvents: {
    readonly AcquireTokenByCode: "acquireTokenByCode";
    readonly AcquireTokenByRefreshToken: "acquireTokenByRefreshToken";
    readonly AcquireTokenSilent: "acquireTokenSilent";
    readonly AcquireTokenSilentAsync: "acquireTokenSilentAsync";
    readonly AcquireTokenPopup: "acquireTokenPopup";
    readonly AcquireTokenRedirect: "acquireTokenRedirect";
    readonly CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint";
    readonly CryptoOptsSignJwt: "cryptoOptsSignJwt";
    readonly SilentCacheClientAcquireToken: "silentCacheClientAcquireToken";
    readonly SilentIframeClientAcquireToken: "silentIframeClientAcquireToken";
    readonly AwaitConcurrentIframe: "awaitConcurrentIframe";
    readonly SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken";
    readonly SsoSilent: "ssoSilent";
    readonly StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority";
    readonly FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker";
    readonly NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken";
    readonly BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders";
    readonly RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint";
    readonly AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint";
    readonly BrokerHandhshake: "brokerHandshake";
    readonly AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker";
    readonly AcquireTokenByBroker: "acquireTokenByBroker";
    readonly RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest";
    readonly RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken";
    readonly RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken";
    readonly RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken";
    readonly RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody";
    readonly AcquireTokenFromCache: "acquireTokenFromCache";
    readonly SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken";
    readonly SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord";
    readonly AcquireTokenBySilentIframe: "acquireTokenBySilentIframe";
    readonly InitializeBaseRequest: "initializeBaseRequest";
    readonly InitializeSilentRequest: "initializeSilentRequest";
    readonly InitializeClientApplication: "initializeClientApplication";
    readonly SilentIframeClientTokenHelper: "silentIframeClientTokenHelper";
    readonly SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest";
    readonly SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash";
    readonly SilentHandlerLoadFrame: "silentHandlerLoadFrame";
    readonly SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync";
    readonly StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient";
    readonly StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration";
    readonly StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest";
    readonly StandardInteractionClientInitializeAuthorizationCodeRequest: "standardInteractionClientInitializeAuthorizationCodeRequest";
    readonly GetAuthCodeUrl: "getAuthCodeUrl";
    readonly HandleCodeResponseFromServer: "handleCodeResponseFromServer";
    readonly HandleCodeResponse: "handleCodeResponse";
    readonly UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority";
    readonly AuthClientAcquireToken: "authClientAcquireToken";
    readonly AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest";
    readonly AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody";
    readonly AuthClientCreateQueryString: "authClientCreateQueryString";
    readonly PopTokenGenerateCnf: "popTokenGenerateCnf";
    readonly PopTokenGenerateKid: "popTokenGenerateKid";
    readonly HandleServerTokenResponse: "handleServerTokenResponse";
    readonly DeserializeResponse: "deserializeResponse";
    readonly AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance";
    readonly AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync";
    readonly AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources";
    readonly AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork";
    readonly AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata";
    readonly AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork";
    readonly AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata";
    readonly AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation";
    readonly RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion";
    readonly RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS";
    readonly RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion";
    readonly AcquireTokenByCodeAsync: "acquireTokenByCodeAsync";
    readonly GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork";
    readonly GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement";
    readonly HandleRedirectPromiseMeasurement: "handleRedirectPromise";
    readonly HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise";
    readonly UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement";
    readonly UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken";
    readonly NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake";
    readonly NativeGenerateAuthResult: "nativeGenerateAuthResult";
    readonly RemoveHiddenIframe: "removeHiddenIframe";
    readonly ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims";
    readonly CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken";
    readonly GeneratePkceCodes: "generatePkceCodes";
    readonly GenerateCodeVerifier: "generateCodeVerifier";
    readonly GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier";
    readonly Sha256Digest: "sha256Digest";
    readonly GetRandomValues: "getRandomValues";
};

// @public (undocumented)
export type PerformanceEvents = (typeof PerformanceEvents)[keyof typeof PerformanceEvents];

// @public
export const PerformanceEventStatus: {
    readonly NotStarted: 0;
    readonly InProgress: 1;
    readonly Completed: 2;
};

// @public (undocumented)
export type PerformanceEventStatus = (typeof PerformanceEventStatus)[keyof typeof PerformanceEventStatus];

// @public
export const PersistentCacheKeys: {
    readonly ID_TOKEN: "idtoken";
    readonly CLIENT_INFO: "client.info";
    readonly ADAL_ID_TOKEN: "adal.idtoken";
    readonly ERROR: "error";
    readonly ERROR_DESC: "error.description";
    readonly ACTIVE_ACCOUNT: "active-account";
    readonly ACTIVE_ACCOUNT_FILTERS: "active-account-filters";
};

// @public (undocumented)
export type PersistentCacheKeys = (typeof PersistentCacheKeys)[keyof typeof PersistentCacheKeys];

// @public
export type PkceCodes = {
    verifier: string;
    challenge: string;
};

// @public (undocumented)
const pkceParamsMissing = "pkce_params_missing";

// Warning: (ae-internal-missing-underscore) The name "PopTokenGenerator" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class PopTokenGenerator {
    constructor(cryptoUtils: ICrypto, performanceClient?: IPerformanceClient);
    // Warning: (ae-forgotten-export) The symbol "ReqCnfData" needs to be exported by the entry point index.d.ts
    generateCnf(request: SignedHttpRequestParameters, logger: Logger): Promise<ReqCnfData>;
    // Warning: (ae-forgotten-export) The symbol "ReqCnf" needs to be exported by the entry point index.d.ts
    generateKid(request: SignedHttpRequestParameters): Promise<ReqCnf>;
    signPayload(payload: string, keyId: string, request: SignedHttpRequestParameters, claims?: object): Promise<string>;
    signPopToken(accessToken: string, keyId: string, request: SignedHttpRequestParameters): Promise<string>;
}

// @public (undocumented)
const POST_LOGOUT_URI = "post_logout_redirect_uri";

// @public (undocumented)
const postRequestFailed = "post_request_failed";

// @public (undocumented)
export interface PreQueueEvent {
    // (undocumented)
    name: PerformanceEvents;
    // (undocumented)
    time: number;
}

// @public (undocumented)
const PROMPT = "prompt";

// @public
export const PromptValue: {
    LOGIN: string;
    SELECT_ACCOUNT: string;
    CONSENT: string;
    NONE: string;
    CREATE: string;
    NO_SESSION: string;
};

// @public
export const ProtocolMode: {
    readonly AAD: "AAD";
    readonly OIDC: "OIDC";
};

// @public (undocumented)
export type ProtocolMode = (typeof ProtocolMode)[keyof typeof ProtocolMode];

// @public
export class ProtocolUtils {
    static generateLibraryState(cryptoObj: ICrypto, meta?: Record<string, string>): string;
    static parseRequestState(cryptoObj: ICrypto, state: string): RequestStateObject;
    static setRequestState(cryptoObj: ICrypto, userState?: string, meta?: Record<string, string>): string;
}

// @public
export type QueueMeasurement = {
    eventName: string;
    queueTime: number;
    manuallyCompleted?: boolean;
};

// @public (undocumented)
const REDIRECT_URI = "redirect_uri";

// @public (undocumented)
const redirectUriEmpty = "redirect_uri_empty";

// @public (undocumented)
const REFRESH_TOKEN = "refresh_token";

// @public (undocumented)
const REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";

// Warning: (ae-internal-missing-underscore) The name "RefreshTokenCache" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type RefreshTokenCache = Record<string, RefreshTokenEntity>;

// Warning: (ae-internal-missing-underscore) The name "RefreshTokenClient" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class RefreshTokenClient extends BaseClient {
    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient);
    // (undocumented)
    acquireToken(request: CommonRefreshTokenRequest): Promise<AuthenticationResult>;
    acquireTokenByRefreshToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult>;
}

// @public
export type RefreshTokenEntity = CredentialEntity & {
    expiresOn?: string;
};

// @public (undocumented)
const refreshTokenExpired = "refresh_token_expired";

// @public (undocumented)
const REQ_CNF = "req_cnf";

// @public (undocumented)
const requestCannotBeMade = "request_cannot_be_made";

// @public (undocumented)
const REQUESTED_TOKEN_USE = "requested_token_use";

// Warning: (ae-internal-missing-underscore) The name "RequestParameterBuilder" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class RequestParameterBuilder {
    constructor();
    addApplicationTelemetry(appTelemetry: ApplicationTelemetry): void;
    addAuthorizationCode(code: string): void;
    addCcsOid(clientInfo: ClientInfo): void;
    addCcsUpn(loginHint: string): void;
    addClaims(claims?: string, clientCapabilities?: Array<string>): void;
    addClientAssertion(clientAssertion: string): void;
    addClientAssertionType(clientAssertionType: string): void;
    // (undocumented)
    addClientCapabilitiesToClaims(claims?: string, clientCapabilities?: Array<string>): string;
    addClientId(clientId: string): void;
    addClientInfo(): void;
    addClientSecret(clientSecret: string): void;
    addCodeChallengeParams(codeChallenge: string, codeChallengeMethod: string): void;
    addCodeVerifier(codeVerifier: string): void;
    addCorrelationId(correlationId: string): void;
    addDeviceCode(code: string): void;
    addDomainHint(domainHint: string): void;
    addExtraQueryParameters(eQParams: StringDict): void;
    addGrantType(grantType: string): void;
    addIdTokenHint(idTokenHint: string): void;
    addLibraryInfo(libraryInfo: LibraryInfo): void;
    addLoginHint(loginHint: string): void;
    addLogoutHint(logoutHint: string): void;
    addNativeBroker(): void;
    addNonce(nonce: string): void;
    addOboAssertion(oboAssertion: string): void;
    addPassword(password: string): void;
    addPopToken(cnfString: string): void;
    addPostLogoutRedirectUri(redirectUri: string): void;
    addPrompt(prompt: string): void;
    addRedirectUri(redirectUri: string): void;
    addRefreshToken(refreshToken: string): void;
    addRequestTokenUse(tokenUse: string): void;
    addResponseMode(responseMode?: ResponseMode): void;
    addResponseTypeCode(): void;
    addResponseTypeForTokenAndIdToken(): void;
    addScopes(scopes: string[], addOidcScopes?: boolean, defaultScopes?: Array<string>): void;
    addServerTelemetry(serverTelemetryManager: ServerTelemetryManager): void;
    addSid(sid: string): void;
    addSshJwk(sshJwkString: string): void;
    addState(state: string): void;
    addThrottling(): void;
    addUsername(username: string): void;
    createQueryString(): string;
}

// @public
export type RequestStateObject = {
    userRequestState: string;
    libraryState: LibraryStateObject;
};

// @public
export type RequestThumbprint = {
    clientId: string;
    authority: string;
    scopes: Array<string>;
    homeAccountIdentifier?: string;
    claims?: string;
    authenticationScheme?: AuthenticationScheme;
    resourceRequestMethod?: string;
    resourceRequestUri?: string;
    shrClaims?: string;
    sshKid?: string;
    shrOptions?: ShrOptions;
};

// @public (undocumented)
const RESPONSE_MODE = "response_mode";

// @public (undocumented)
const RESPONSE_TYPE = "response_type";

// Warning: (ae-internal-missing-underscore) The name "ResponseHandler" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class ResponseHandler {
    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger, serializableCache: ISerializableTokenCache | null, persistencePlugin: ICachePlugin | null, performanceClient?: IPerformanceClient);
    static generateAuthenticationResult(cryptoObj: ICrypto, authority: Authority, cacheRecord: CacheRecord, fromTokenCache: boolean, request: BaseAuthRequest, idTokenClaims?: TokenClaims, requestState?: RequestStateObject, serverTokenResponse?: ServerAuthorizationTokenResponse, requestId?: string): Promise<AuthenticationResult>;
    handleServerTokenResponse(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, reqTimestamp: number, request: BaseAuthRequest, authCodePayload?: AuthorizationCodePayload, userAssertionHash?: string, handlingRefreshTokenResponse?: boolean, forceCacheRefreshTokenResponse?: boolean, serverRequestId?: string): Promise<AuthenticationResult>;
    validateServerAuthorizationCodeResponse(serverResponse: ServerAuthorizationCodeResponse, requestState: string): void;
    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse, refreshAccessToken?: boolean): void;
}

// @public
export const ResponseMode: {
    readonly FORM_POST: "form_post";
    readonly QUERY: "query";
    readonly FRAGMENT: "fragment";
};

// @public (undocumented)
export type ResponseMode = (typeof ResponseMode)[keyof typeof ResponseMode];

// @public (undocumented)
const RETURN_SPA_CODE = "return_spa_code";

// @public (undocumented)
const SCOPE = "scope";

// @public
export class ScopeSet {
    constructor(inputScopes: Array<string>);
    appendScope(newScope: string): void;
    appendScopes(newScopes: Array<string>): void;
    asArray(): Array<string>;
    containsOnlyOIDCScopes(): boolean;
    containsScope(scope: string): boolean;
    containsScopeSet(scopeSet: ScopeSet): boolean;
    static createSearchScopes(inputScopeString: Array<string>): ScopeSet;
    static fromString(inputScopeString: string): ScopeSet;
    getScopeCount(): number;
    intersectingScopeSets(otherScopes: ScopeSet): boolean;
    printScopes(): string;
    printScopesLowerCase(): string;
    removeOIDCScopes(): void;
    removeScope(scope: string): void;
    unionScopeSets(otherScopes: ScopeSet): Set<string>;
}

// @public
export type ServerAuthorizationCodeResponse = {
    code?: string;
    client_info?: string;
    state?: string;
    cloud_instance_name?: string;
    cloud_instance_host_name?: string;
    cloud_graph_host_name?: string;
    msgraph_host?: string;
    error?: string;
    error_uri?: string;
    error_description?: string;
    suberror?: string;
    timestamp?: string;
    trace_id?: string;
    correlation_id?: string;
    claims?: string;
    accountId?: string;
};

// @public
export type ServerAuthorizationTokenResponse = {
    status?: number;
    token_type?: AuthenticationScheme;
    scope?: string;
    expires_in?: number;
    refresh_in?: number;
    ext_expires_in?: number;
    access_token?: string;
    refresh_token?: string;
    refresh_token_expires_in?: number;
    id_token?: string;
    client_info?: string;
    foci?: string;
    spa_code?: string;
    spa_accountid?: string;
    key_id?: string;
    error?: string;
    error_description?: string;
    error_codes?: Array<string>;
    suberror?: string;
    timestamp?: string;
    trace_id?: string;
    correlation_id?: string;
    claims?: string;
};

// @public (undocumented)
export type ServerDeviceCodeResponse = {
    user_code: string;
    device_code: string;
    verification_uri: string;
    expires_in: number;
    interval: number;
    message: string;
};

// @public
export class ServerError extends AuthError {
    constructor(errorCode?: string, errorMessage?: string, subError?: string, errorNo?: string);
    readonly errorNo?: string;
}

// @public
export const ServerResponseType: {
    readonly QUERY: "query";
    readonly FRAGMENT: "fragment";
};

// @public (undocumented)
export type ServerResponseType = (typeof ServerResponseType)[keyof typeof ServerResponseType];

// @public (undocumented)
export type ServerTelemetryEntity = {
    failedRequests: Array<string | number>;
    errors: string[];
    cacheHits: number;
};

// Warning: (ae-internal-missing-underscore) The name "ServerTelemetryManager" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ServerTelemetryManager {
    constructor(telemetryRequest: ServerTelemetryRequest, cacheManager: CacheManager);
    cacheFailedRequest(error: unknown): void;
    clearTelemetryCache(): void;
    generateCurrentRequestHeaderValue(): string;
    generateLastRequestHeaderValue(): string;
    getLastRequests(): ServerTelemetryEntity;
    getRegionDiscoveryFields(): string;
    incrementCacheHits(): number;
    static maxErrorsToSend(serverTelemetryEntity: ServerTelemetryEntity): number;
    setCacheOutcome(cacheOutcome: CacheOutcome): void;
    updateRegionDiscoveryMetadata(regionDiscoveryMetadata: RegionDiscoveryMetadata): void;
}

// @public (undocumented)
export type ServerTelemetryRequest = {
    clientId: string;
    apiId: number;
    correlationId: string;
    forceRefresh?: boolean;
    wrapperSKU?: string;
    wrapperVer?: string;
};

// @public (undocumented)
const SESSION_STATE = "session_state";

// @public (undocumented)
export type ShrOptions = {
    header: JoseHeaderOptions;
};

// @public (undocumented)
const SID = "sid";

// @public (undocumented)
export type SignedHttpRequest = {
    at?: string;
    cnf?: object;
    m?: string;
    u?: string;
    p?: string;
    q?: [Array<string>, string];
    ts?: number;
    nonce?: string;
    client_claims?: string;
};

// @public (undocumented)
export type SignedHttpRequestParameters = Pick<BaseAuthRequest, "resourceRequestMethod" | "resourceRequestUri" | "shrClaims" | "shrNonce" | "shrOptions"> & {
    correlationId?: string;
};

// Warning: (ae-internal-missing-underscore) The name "SilentFlowClient" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class SilentFlowClient extends BaseClient {
    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient);
    acquireCachedToken(request: CommonSilentFlowRequest): Promise<[AuthenticationResult, CacheOutcome]>;
    acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult>;
}

// @public (undocumented)
const STATE = "state";

// @public (undocumented)
const stateMismatch = "state_mismatch";

// @public (undocumented)
const stateNotFound = "state_not_found";

// @public (undocumented)
export type StaticAuthorityOptions = Partial<Pick<AuthorityOptions, "knownAuthorities">> & {
    canonicalAuthority?: string;
    cloudDiscoveryMetadata?: CloudInstanceDiscoveryResponse;
};

// @public
export type StoreInCache = {
    accessToken?: boolean;
    idToken?: boolean;
    refreshToken?: boolean;
};

// @public
export type StringDict = {
    [key: string]: string;
};

// @public (undocumented)
export class StringUtils {
    // (undocumented)
    static endsWith(str: string, search: string): boolean;
    static isEmptyObj(strObj?: string): boolean;
    static jsonParseHelper<T>(str: string): T | null;
    static matchPattern(pattern: string, input: string): boolean;
    static queryStringToObject<T>(query: string): T;
    static removeEmptyStringsFromArray(arr: Array<string>): Array<string>;
    // (undocumented)
    static startsWith(str: string, search: string): boolean;
    static trimArrayEntries(arr: Array<string>): Array<string>;
}

// @public
function stripLeadingHashOrQuery(responseString: string): string;

// @public (undocumented)
export const StubbedNetworkModule: INetworkModule;

// @public (undocumented)
export class StubPerformanceClient implements IPerformanceClient {
    // (undocumented)
    addFields(): void;
    // (undocumented)
    addPerformanceCallback(): string;
    // (undocumented)
    addQueueMeasurement(): void;
    // (undocumented)
    cacheEventByCorrelationId(): void;
    // (undocumented)
    calculateQueuedTime(): number;
    // (undocumented)
    discardMeasurements(): void;
    // (undocumented)
    emitEvents(): void;
    // (undocumented)
    endMeasurement(): PerformanceEvent | null;
    // (undocumented)
    generateId(): string;
    // (undocumented)
    incrementFields(): void;
    // (undocumented)
    removePerformanceCallback(): boolean;
    // (undocumented)
    setPreQueueTime(): void;
    // (undocumented)
    startMeasurement(measureName: string, correlationId?: string | undefined): InProgressPerformanceEvent;
    // (undocumented)
    startPerformanceMeasurement(): IPerformanceMeasurement;
}

// @public (undocumented)
export type SubMeasurement = {
    name: string;
    startTimeMs: number;
};

// @public
export type SystemOptions = {
    tokenRenewalOffsetSeconds?: number;
    preventCorsPreflight?: boolean;
};

// @public
export function tenantIdMatchesHomeTenant(tenantId?: string, homeAccountId?: string): boolean;

// @public
export type TenantProfile = Pick<AccountInfo, "tenantId" | "localAccountId" | "name"> & {
    isHomeTenant?: boolean;
};

// @public (undocumented)
export const THE_FAMILY_ID = "1";

// @public
export const ThrottlingConstants: {
    DEFAULT_THROTTLE_TIME_SECONDS: number;
    DEFAULT_MAX_THROTTLE_TIME_SECONDS: number;
    THROTTLING_PREFIX: string;
    X_MS_LIB_CAPABILITY_VALUE: string;
};

// @public (undocumented)
export type ThrottlingEntity = {
    throttleTime: number;
    error?: string;
    errorCodes?: Array<string>;
    errorMessage?: string;
    subError?: string;
};

// Warning: (ae-internal-missing-underscore) The name "ThrottlingUtils" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ThrottlingUtils {
    static calculateThrottleTime(throttleTime: number): number;
    static checkResponseForRetryAfter(response: NetworkResponse<ServerAuthorizationTokenResponse>): boolean;
    static checkResponseStatus(response: NetworkResponse<ServerAuthorizationTokenResponse>): boolean;
    static generateThrottlingStorageKey(thumbprint: RequestThumbprint): string;
    static postProcess(cacheManager: CacheManager, thumbprint: RequestThumbprint, response: NetworkResponse<ServerAuthorizationTokenResponse>): void;
    static preProcess(cacheManager: CacheManager, thumbprint: RequestThumbprint): void;
    // (undocumented)
    static removeThrottle(cacheManager: CacheManager, clientId: string, request: BaseAuthRequest, homeAccountIdentifier?: string): void;
}

declare namespace TimeUtils {
    export {
        nowSeconds,
        isTokenExpired,
        wasClockTurnedBack,
        delay
    }
}
export { TimeUtils }

// @public (undocumented)
const TOKEN_TYPE = "token_type";

// @public
export class TokenCacheContext {
    constructor(tokenCache: ISerializableTokenCache, hasChanged: boolean);
    cache: ISerializableTokenCache;
    get cacheHasChanged(): boolean;
    hasChanged: boolean;
    get tokenCache(): ISerializableTokenCache;
}

// @public
type TokenClaims = {
    aud?: string;
    iss?: string;
    iat?: number;
    nbf?: number;
    oid?: string;
    sub?: string;
    tid?: string;
    tfp?: string;
    acr?: string;
    ver?: string;
    upn?: string;
    preferred_username?: string;
    login_hint?: string;
    emails?: string[];
    name?: string;
    nonce?: string;
    exp?: number;
    home_oid?: string;
    sid?: string;
    cloud_instance_host_name?: string;
    cnf?: {
        kid: string;
    };
    x5c_ca?: string[];
    ts?: number;
    at?: string;
    u?: string;
    p?: string;
    m?: string;
    roles?: string[];
    amr?: string[];
    idp?: string;
    auth_time?: number;
    tenant_region_scope?: string;
    tenant_region_sub_scope?: string;
};
export { TokenClaims as IdTokenClaims }
export { TokenClaims }

// @public (undocumented)
const tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";

// @public (undocumented)
export type TokenKeys = {
    idToken: string[];
    accessToken: string[];
    refreshToken: string[];
};

// @public (undocumented)
const tokenParsingError = "token_parsing_error";

// @public (undocumented)
const tokenRefreshRequired = "token_refresh_required";

// @public (undocumented)
const tokenRequestEmpty = "token_request_empty";

// @public (undocumented)
const unexpectedCredentialType = "unexpected_credential_type";

// @public
const unexpectedError = "unexpected_error";

// @public (undocumented)
const untrustedAuthority = "untrusted_authority";

// @public
export function updateAccountTenantProfileData(baseAccountInfo: AccountInfo, tenantProfile?: TenantProfile, idTokenClaims?: TokenClaims, idTokenSecret?: string): AccountInfo;

// Warning: (ae-incompatible-release-tags) The symbol "updateAuthorityEndpointMetadata" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "updateAuthorityEndpointMetadata" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
//
// @public (undocumented)
function updateAuthorityEndpointMetadata(authorityMetadata: AuthorityMetadataEntity, updatedValues: OpenIdConfigResponse, fromNetwork: boolean): void;

// Warning: (ae-incompatible-release-tags) The symbol "updateCloudDiscoveryMetadata" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "updateCloudDiscoveryMetadata" is marked as @public, but its signature references "AuthorityMetadataEntity" which is marked as @internal
//
// @public (undocumented)
function updateCloudDiscoveryMetadata(authorityMetadata: AuthorityMetadataEntity, updatedValues: CloudDiscoveryMetadata, fromNetwork: boolean): void;

// @public (undocumented)
const urlEmptyError = "empty_url_error";

// @public (undocumented)
const urlParseError = "url_parse_error";

// @public
export class UrlString {
    constructor(url: string);
    static appendQueryString(url: string, queryString: string): string;
    static canonicalizeUri(url: string): string;
    // (undocumented)
    static constructAuthorityUriFromObject(urlObject: IUri): UrlString;
    // (undocumented)
    static getAbsoluteUrl(relativeUrl: string, baseUrl: string): string;
    // (undocumented)
    static getDomainFromUrl(url: string): string;
    getUrlComponents(): IUri;
    // @deprecated
    static hashContainsKnownProperties(response: string): boolean;
    static removeHashFromUrl(url: string): string;
    replaceTenantPath(tenantId: string): UrlString;
    // (undocumented)
    get urlString(): string;
    validateAsUri(): void;
}

// @public (undocumented)
export type UrlToHttpRequestOptions = {
    protocol: string;
    hostname: string;
    hash: string;
    search: string;
    pathname: string;
    path: string;
    href: string;
    port?: number;
    auth?: string;
};

declare namespace UrlUtils {
    export {
        stripLeadingHashOrQuery,
        getDeserializedResponse
    }
}
export { UrlUtils }

// @public (undocumented)
const userCanceled = "user_canceled";

// @public (undocumented)
const userTimeoutReached = "user_timeout_reached";

// Warning: (ae-internal-missing-underscore) The name "ValidCacheType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type ValidCacheType = AccountEntity | IdTokenEntity | AccessTokenEntity | RefreshTokenEntity | AppMetadataEntity | AuthorityMetadataEntity | ServerTelemetryEntity | ThrottlingEntity | string;

// Warning: (ae-internal-missing-underscore) The name "ValidCredentialType" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type ValidCredentialType = IdTokenEntity | AccessTokenEntity | RefreshTokenEntity;

// @public (undocumented)
export const version = "14.9.0";

// @public
function wasClockTurnedBack(cachedAt: string): boolean;

// @public (undocumented)
const X_APP_NAME = "x-app-name";

// @public (undocumented)
const X_APP_VER = "x-app-ver";

// @public (undocumented)
const X_CLIENT_CPU = "x-client-CPU";

// @public (undocumented)
const X_CLIENT_CURR_TELEM = "x-client-current-telemetry";

// @public (undocumented)
const X_CLIENT_LAST_TELEM = "x-client-last-telemetry";

// @public (undocumented)
const X_CLIENT_OS = "x-client-OS";

// @public (undocumented)
const X_CLIENT_SKU = "x-client-SKU";

// @public (undocumented)
const X_CLIENT_VER = "x-client-VER";

// @public (undocumented)
const X_MS_LIB_CAPABILITY = "x-ms-lib-capability";

// Warnings were encountered during analysis:
//
// src/authority/AuthorityOptions.ts:26:5 - (ae-forgotten-export) The symbol "CloudInstanceDiscoveryResponse" needs to be exported by the entry point index.d.ts
// src/config/ClientConfiguration.ts:50:5 - (ae-forgotten-export) The symbol "ClientCredentials" needs to be exported by the entry point index.d.ts
// src/config/ClientConfiguration.ts:51:5 - (ae-forgotten-export) The symbol "LibraryInfo" needs to be exported by the entry point index.d.ts
// src/config/ClientConfiguration.ts:52:5 - (ae-forgotten-export) The symbol "TelemetryOptions" needs to be exported by the entry point index.d.ts

```
